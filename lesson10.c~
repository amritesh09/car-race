#include <GL/glut.h>    // Header File For The GLUT Library 
#include <GL/gl.h>	// Header File For The OpenGL32 Library
#include <GL/glu.h>	// Header File For The GLu32 Library
#include <unistd.h>     // Header file for sleeping.
#include <stdio.h>      // Header file for standard file i/o.
#include <stdlib.h>     // Header file for malloc/free.
#include <math.h>       // Header file for trigonometric functions.
#include <string.h>
/* the ascii codes for various special keys */
#define ESCAPE 27
#define SPACE 32
#define PAGE_UP 73
#define PAGE_DOWN 81
#define UP_ARROW 72
#define DOWN_ARROW 80
#define LEFT_ARROW 75
#define RIGHT_ARROW 77


int window; 
int menu=1;
GLuint loop;             
GLuint texture[3],texture_bg;       

int keybuff[246];
int light = 0;           
int blend = 0;        

GLfloat xrot;            
GLfloat yrot;            
GLfloat xspeed;          
GLfloat yspeed;         

GLfloat walkbias = 0;
GLfloat walkbiasangle = 0;

GLfloat lookupdown = 0.0;		//0.0
const float piover180 = 0.0174532925f;

float heading, xpos, zpos;

GLfloat camx = 0, camy = 0, camz = 0; // camera location.
GLfloat therotate;

GLfloat z=0.0f;                      

GLfloat LightAmbient[]  = {0.5f, 0.5f, 0.5f, 1.0f}; 
GLfloat LightDiffuse[]  = {1.0f, 1.0f, 1.0f, 1.0f}; 
GLfloat LightPosition[] = {0.0f, 0.0f, 2.0f, 1.0f};

GLuint filter = 1;       // texture filtering method to use (nearest, linear, linear + mipmaps)

typedef struct {         // vertex coordinates - 3d and texture
    GLfloat x, y, z;     // 3d coords.
    GLfloat u, v;        // texture coords.
} VERTEX;

typedef struct {         // triangle
    VERTEX vertex[3];    // 3 vertices array
} TRIANGLE;

typedef struct {         // sector of a 3d environment
    int numtriangles;    // number of triangles in the sector
    TRIANGLE* triangle;  // pointer to array of triangles.
} SECTOR;

SECTOR sector1;

/* Image type - contains height, width, and data */
typedef struct {
    unsigned long sizeX;
    unsigned long sizeY;
    char *data;
} Image;

// degrees to radians...2 PI radians = 360 degrees
float rad(float angle)
{
    return angle * piover180;
}

// helper for SetupWorld. 
void readstr(FILE *f, char *string)
{
    do {
	fgets(string, 255, f); // read the line
    } while ((string[0] == '/') || (string[0] == '\n'));
    return;
}

// loads the world from a text file.
void SetupWorld() 
{	int i=0;
	for(i=0;i<246;i++)keybuff[i]=0;
    float x, y, z, u, v;
    int vert;
    int numtriangles;
    FILE *filein;        // file to load the world from
    char oneline[255];

    filein = fopen("../resources/world8.txt", "rt");

    readstr(filein, oneline);
    sscanf(oneline, "NUMPOLLIES %d\n", &numtriangles);

    sector1.numtriangles = numtriangles;
    sector1.triangle = (TRIANGLE *) malloc(sizeof(TRIANGLE)*numtriangles);
    
    for (loop = 0; loop < numtriangles; loop++) {
	for (vert = 0; vert < 3; vert++) {
	    readstr(filein,oneline);
	    sscanf(oneline, "%f %f %f %f %f", &x, &y, &z, &u, &v);
	    sector1.triangle[loop].vertex[vert].x = x;
	    sector1.triangle[loop].vertex[vert].y = y;
	    sector1.triangle[loop].vertex[vert].z = z;
	    sector1.triangle[loop].vertex[vert].u = u;
	    sector1.triangle[loop].vertex[vert].v = v;
	}
    }

    fclose(filein);
    return;
}
    
/* getint and getshort are help functions to load the bitmap byte by byte*/
static unsigned int getint(fp)
     FILE *fp;
{
  int c, c1, c2, c3;

  // get 4 bytes
  c = getc(fp);  
  c1 = getc(fp);  
  c2 = getc(fp);  
  c3 = getc(fp);
  
  return ((unsigned int) c) +   
    (((unsigned int) c1) << 8) + 
    (((unsigned int) c2) << 16) +
    (((unsigned int) c3) << 24);
}

static unsigned int getshort(fp)
     FILE *fp;
{
  int c, c1;
  
  //get 2 bytes
  c = getc(fp);  
  c1 = getc(fp);

  return ((unsigned int) c) + (((unsigned int) c1) << 8);
}

int ImageLoad(char *filename, Image *image) 
{
    FILE *file;
    unsigned long size;                 // size of the image in bytes.
    unsigned long i;                    // standard counter.
    unsigned short int planes;          // number of planes in image
    unsigned short int bpp;             // number of bits per pixel
    char temp;                          // used to convert bgr to rgb color.

    // make sure the file is there.
    if ((file = fopen(filename, "rb"))==NULL) {
      printf("File Not Found : %s\n",filename);
      return 0;
    }
    
    // seek through the bmp header, up to the width/height:
    fseek(file, 18, SEEK_CUR);

     // read the width
    image->sizeX = getint (file);
    
    // read the height 
    image->sizeY = getint (file);
    
    // calculate the size 
    size = image->sizeX * image->sizeY * 3;

    // read the planes
    planes = getshort(file);
    if (planes != 1) {
	printf("Planes from %s is not 1: %u\n", filename, planes);
	return 0;
    }

    
    bpp = getshort(file);
    if (bpp != 24) {
      printf("Bpp from %s is not 24: %u\n", filename, bpp);
      return 0;
    }
	
    // seek past the rest of the bitmap header.
    fseek(file, 24, SEEK_CUR);

    // read the data. 
    image->data = (char *) malloc(size);
    if (image->data == NULL) {
	printf("Error allocating memory for color-corrected image data");
	return 0;	
    }

    if ((i = fread(image->data, size, 1, file)) != 1) {
	printf("Error reading image data from %s.\n", filename);
	return 0;
    }

    for (i=0;i<size;i+=3) { // reverse all of the colors. (bgr -> rgb)
	temp = image->data[i];
	image->data[i] = image->data[i+2];
	image->data[i+2] = temp;
    }

     return 1;
}

// Load Bitmaps And Convert To Textures
GLvoid LoadGLTextures(GLvoid) 
{	
    // Load Texture
    Image *image1;
    Image *image_bg;//bg image
    
    // allocate space for texture
    image1 = (Image *) malloc(sizeof(Image));image_bg=(Image *) malloc(sizeof(Image));
    if (image1 == NULL) {
	printf("Error allocating space for image");
	exit(0);
    }

    if (!ImageLoad("../resources/road.bmp", image1)) {
	exit(1);
    }        
   if (!ImageLoad("../resources/bg1.bmp", image_bg)) {
	exit(1);
    }  
    // Create Textures	
    glGenTextures(3, &texture[0]);glGenTextures(3, &texture_bg);

    // nearest filtered texture
    glBindTexture(GL_TEXTURE_2D, texture[0]);   // 2d texture (x and y size)
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_NEAREST); // scale  when image bigger than texture
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_NEAREST); // scale  when image smalled than texture
    glTexImage2D(GL_TEXTURE_2D, 0, 3, image1->sizeX, image1->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, image1->data);

    // linear filtered texture
    glBindTexture(GL_TEXTURE_2D, texture[1]);   // 2d texture (x and y size)
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR); // scale linearly when image bigger than texture
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); // scale linearly when image smalled than texture
    glTexImage2D(GL_TEXTURE_2D, 0, 3, image1->sizeX, image1->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, image1->data);


    // linear filtered texture  for background
    glBindTexture(GL_TEXTURE_2D, texture_bg);   // 2d texture (x and y size)
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR); // scale linearly when image bigger than texture
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR); // scale linearly when image smalled than texture
    glTexImage2D(GL_TEXTURE_2D, 0, 3, image_bg->sizeX, image_bg->sizeY, 0, GL_RGB, GL_UNSIGNED_BYTE, image_bg->data);
    
	// mipmapped texture
    glBindTexture(GL_TEXTURE_2D, texture[2]);   // 2d texture (x and y size)
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MAG_FILTER,GL_LINEAR); // scale linearly when image bigger than texture
    glTexParameteri(GL_TEXTURE_2D,GL_TEXTURE_MIN_FILTER,GL_LINEAR_MIPMAP_NEAREST); // scale mipmap when image smalled than texture
    gluBuild2DMipmaps(GL_TEXTURE_2D, 3, image1->sizeX, image1->sizeY, GL_RGB, GL_UNSIGNED_BYTE, image1->data);
};

/* A general OpenGL initialization function.  Sets all of the initial parameters. */
GLvoid InitGL(GLsizei Width, GLsizei Height)	// We call this right after our OpenGL window is created.
{
    LoadGLTextures();                           // load the textures.
    glEnable(GL_TEXTURE_2D);                    // Enable texture mapping.

    glBlendFunc(GL_SRC_ALPHA, GL_ONE);          // Set the blending function for translucency (note off at init time)
    glClearColor(0.0f, 0.0f, 0.0f, 0.0f);	// This Will Clear The Background Color To Black
    glClearDepth(1.0);				// Enables Clearing Of The Depth Buffer
    glDepthFunc(GL_LESS);                       // type of depth test to do.
    glEnable(GL_DEPTH_TEST);                    // enables depth testing.
    glShadeModel(GL_SMOOTH);			// Enables Smooth Color Shading
    
    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();				// Reset The Projection Matrix
    
    gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.5f,100.0f);	// Calculate The Aspect Ratio Of The Window
    
    glMatrixMode(GL_MODELVIEW);
	//lookupdown = 4.0;
    // set up lights.
    glLightfv(GL_LIGHT1, GL_AMBIENT, LightAmbient);
    glLightfv(GL_LIGHT1, GL_DIFFUSE, LightDiffuse);
    glLightfv(GL_LIGHT1, GL_POSITION, LightPosition);
    glEnable(GL_LIGHT1);
}

/* The function called when our window is resized */
GLvoid ReSizeGLScene(GLsizei Width, GLsizei Height)
{lookupdown=8.0;
    if (Height==0)				// Prevent A Divide By Zero If The Window Is Too Small
	Height=1;
	//edit for view rectangle
    glViewport(0, 0, Width, Height);		// Reset The Current Viewport And Perspective Transformation

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity();

    gluPerspective(45.0f,(GLfloat)Width/(GLfloat)Height,0.5f,200.0f);//100 initially
    glMatrixMode(GL_MODELVIEW);
}

void keyOperations (void) {
if(menu!=1){
 if(keybuff[GLUT_KEY_UP]==1){
	xpos -= (float)sin(yrot*piover180) * 0.5f;
	zpos -= (float)cos(yrot*piover180) * 0.5f;//0.05f;//10.0f;//0.05f	
	if (walkbiasangle >= 359.0f)
	    walkbiasangle = 0.0f;	
	//else 
	   // walkbiasangle+= 10;		wave effect
	//walkbias = (float)sin(walkbiasangle * piover180)/20.0f;
	
	}

 if(keybuff[GLUT_KEY_DOWN]==1){ // walk back (bob head)
	xpos += (float)sin(yrot*piover180) * 0.05f;
	zpos += (float)cos(yrot*piover180) * 0.5f;//0.05f;//10.0f;	
	if (walkbiasangle <= 1.0f)
	    walkbiasangle = 359.0f;	
	else 
	    //walkbiasangle-= 10;
	walkbias = (float)sin(walkbiasangle * piover180)/20.0f;
	}
if(keybuff[GLUT_KEY_LEFT]==1){ // look left
	yrot += 0.5f;//1.5f
	}
    
    if(keybuff[GLUT_KEY_RIGHT]==1){ // look right
	yrot -= 0.5f;//1.5f
	}
}
}


/* The main drawing function. */
GLvoid DrawGLScene(GLvoid)
{	keyOperations();   //perform key operations first
    GLfloat x_m, y_m, z_m, u_m, v_m;
    GLfloat xtrans, ztrans, ytrans;
    GLfloat sceneroty;
    int numtriangles;
	//display menu

    // calculate translations and rotations.
    xtrans = -xpos;
    ztrans = -zpos;
    ytrans = -walkbias-0.25f;
    sceneroty = 360.0f - yrot;
    	
    glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);		
    glLoadIdentity();

    glRotatef(lookupdown, 1.0f, 0, 0);
    glRotatef(sceneroty, 0, 1.0f, 0);

    glTranslatef(xtrans, ytrans*8, ztrans);  		//translate TEMP  

//BACKGROUND
	glBindTexture(GL_TEXTURE_2D, texture_bg); //texture for background
	//ground coordinates
	glBegin(GL_QUADS);		
	glNormal3f( 0.0f, 0.0f, 1.0f);	
	glTexCoord2f(0,600); 
	glVertex3f(-300.0,-0.1,-400);
	glTexCoord2f(0,0); 
	glVertex3f(-300,-0.1,300);
	glTexCoord2f(600,0); 
	glVertex3f(300,-0.1,300);
	glTexCoord2f(600,600); 
	glVertex3f(300,-0.1,-400);
	glEnd();
    glBindTexture(GL_TEXTURE_2D, texture[filter]);    // pick the texture.		CHANGE HERE TO CHANGE IMAGE USED

    numtriangles = sector1.numtriangles;

    for (loop=0; loop<numtriangles; loop++) {        // loop through all the triangles 36 here
	glBegin(GL_TRIANGLES);		
	glNormal3f( 0.0f, 0.0f, 1.0f);
	
	x_m = sector1.triangle[loop].vertex[0].x;
	y_m = sector1.triangle[loop].vertex[0].y;
	z_m = sector1.triangle[loop].vertex[0].z;
	u_m = sector1.triangle[loop].vertex[0].u;
	v_m = sector1.triangle[loop].vertex[0].v;
	glTexCoord2f(u_m,v_m); 
	glVertex3f(x_m,y_m,z_m);
	
	x_m = sector1.triangle[loop].vertex[1].x;
	y_m = sector1.triangle[loop].vertex[1].y;
	z_m = sector1.triangle[loop].vertex[1].z;
	u_m = sector1.triangle[loop].vertex[1].u;
	v_m = sector1.triangle[loop].vertex[1].v;
	glTexCoord2f(u_m,v_m); 
	glVertex3f(x_m,y_m,z_m);
	
	x_m = sector1.triangle[loop].vertex[2].x;
	y_m = sector1.triangle[loop].vertex[2].y;
	z_m = sector1.triangle[loop].vertex[2].z;
	u_m = sector1.triangle[loop].vertex[2].u;
	v_m = sector1.triangle[loop].vertex[2].v;
	glTexCoord2f(u_m,v_m); 
	glVertex3f(x_m,y_m,z_m);	
	
	glEnd();	
    }
   if(menu==1)
	{


	int i=0;
//glScalef(3.0,3.0,3.0);
glColor3f(1.0,0.0, 0.0);		//COLOR OF MENU OPTIONS GREEN
glRasterPos3d(-0.9,3.0,-15.0);

char *s1;s1="NEW GAME";
for (i = 0; i <= strlen(s1); i++)
	    {
	       glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, s1[i]);
	    }
glRasterPos3d(-0.9,2.0,-15.0);

char *s2;s2="HIGH SCORE";
for (i = 0; i <= strlen(s2); i++)
	    {
	       glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, s2[i]);
	    }
glRasterPos3d(-0.6,1.0,-15.0);

char *s3;s3="TRACK";
for (i = 0; i <= strlen(s3); i++)
	    {
	       glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, s3[i]);
	    }
glRasterPos3d(-0.4,0.0,-15.0);

char *s4;s4="EXIT";
for (i = 0; i <= strlen(s4); i++)
	    {
	       glutBitmapCharacter(GLUT_BITMAP_TIMES_ROMAN_24, s4[i]);
	    }

glColor3f(1.0,1.0, 1.0);
glFlush();
}

    // since this is double buffered, swap the buffers to display what just got drawn.
    glutSwapBuffers();
}



/* The function called whenever a normal key is pressed. */
void keyPressed(unsigned char key, int x, int y) 
{	
    
    usleep(100);
	keybuff[key]=1; //set key in buffer
    switch (key) {    
    case ESCAPE: // kill everything.
	/* exit the program...normal termination. */
	exit(1);                   	
	break; // redundant.
    case SPACE:menu=0;
		break;
    

    case 'f': glutFullScreen();
		break;
  
	case 'm':
	case 'M':
			menu=1;
			break;
   
    default:
      printf ("Key %d pressed. No action there yet.\n", key);
      break;
    }	
}

/* The function called whenever a normal key is pressed. */
void specialKeyPressed(int key, int x, int y) 
{	
  
    usleep(100);
	keybuff[key]=1; //set key in buffer
	//printf("menu=%d",menu);
   if(menu!=1){ 
	switch (key) {    
    case GLUT_KEY_PAGE_UP: // tilt up
	z -= 0.2f;
	lookupdown -= 0.2f;
	break;
    
    case GLUT_KEY_PAGE_DOWN: // tilt down
	z += 0.2f;
	lookupdown += 1.0f;
	break;

    case GLUT_KEY_UP: // walk forward 
	xpos -= (float)sin(yrot*piover180) * 0.5f;
	zpos -= (float)cos(yrot*piover180) * 0.5f;//0.05f;//10.0f;//0.05f	
	if (walkbiasangle >= 359.0f)
	    walkbiasangle = 0.0f;	
	//else 
	   // walkbiasangle+= 10;		wave effect
	//walkbias = (float)sin(walkbiasangle * piover180)/20.0f;
	break;

    case GLUT_KEY_DOWN: 
	xpos += (float)sin(yrot*piover180) * 0.05f;
	zpos += (float)cos(yrot*piover180) * 0.5f;//0.05f;//10.0f;	
	if (walkbiasangle <= 1.0f)
	    walkbiasangle = 359.0f;	
	else 
	    //walkbiasangle-= 10;
	walkbias = (float)sin(walkbiasangle * piover180)/20.0f;
	break;

    case GLUT_KEY_LEFT: // look left
	yrot += 1.5f;
	break;
    
    case GLUT_KEY_RIGHT: // look right
	yrot -= 1.5f;
	break;

    default:
	printf ("Special key %d pressed. No action there yet.\n", key);
	break;
    }	}
}

void keySpecialUp (int key, int x, int y) {
keybuff[key] = 0; // Set the state of the current key to not pressed
}

void keyUp (unsigned char key, int x, int y) {
keybuff[key] = 0; // Set the state of the current key to not pressed
}

void mouseClicks(int button, int state, int x, int y) {
    if(button == GLUT_LEFT_BUTTON && state == GLUT_DOWN) {
        if(x>620&&x<770&&y>170&&y<190){			//New Game
		menu=0;printf("click %d, %d",x,y);
		}
	else if(x>620&&x<770&&y>240&&y<260){			//Track 625 248,773
		printf("click %d, %d",x,y);
		}
	else if(x>620&&x<770&&y>300&&y<320){			//High Score
		printf("click %d, %d",x,y);
		}
	else if(x>620&&x<770&&y>360&&y<380){			//exit
		printf("click %d, %d",x,y);
		exit(1);                   	
	}
    }
}
int main(int argc, char **argv) 
{  
    /* load our world from disk */
    SetupWorld();

    /* Initialize GLUT state  */  
    glutInit(&argc, argv);  

     
    glutInitDisplayMode(GLUT_RGBA | GLUT_DOUBLE | GLUT_DEPTH | GLUT_ALPHA);  

    /* get a 640 x 480 window */
    glutInitWindowSize(640, 480);  

    /* the window starts at the upper left corner of the screen */
    glutInitWindowPosition(0, 0);  

    /* Open a window */  
    window = glutCreateWindow("Track");  

    /* Register the function to do all our OpenGL drawing. */
    glutDisplayFunc(&DrawGLScene);  

    /* Go fullscreen.  This is as soon as possible. */
   glutFullScreen();

    /* Even if there are no events, redraw our gl scene. */
    glutIdleFunc(&DrawGLScene); 

    /* Register the function called when our window is resized. */
    glutReshapeFunc(&ReSizeGLScene);

    /* Register the function called when the keyboard is pressed. */
    glutKeyboardFunc(&keyPressed);
	glutKeyboardUpFunc(&keyUp);

    /* Register the function called when special keys (arrows, page down, etc) are pressed. */
    glutSpecialFunc(&specialKeyPressed);
	glutSpecialUpFunc(&keySpecialUp);
	/*Mouse click function*/
	glutMouseFunc(mouseClicks);
    /* Initialize our window. */
    InitGL(640, 480);
  
    /* Start Event Processing Engine */  
    glutMainLoop();  

    return 1;
}
